#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t broken-links:nil c:nil creator:nil
#+OPTIONS: d:(not "LOGBOOK") date:t e:t email:nil f:t inline:t num:t
#+OPTIONS: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+OPTIONS: timestamp:t title:t toc:t todo:t |:t
#+TITLE: Майл К. Физерс. Эффективная работа с унаследованным кодом. Реферат
#+DATE: <2018-03-11 Вс>
#+AUTHOR: Роман Зайруллин
#+EMAIL: krosenmann@gmail.com
#+LANGUAGE: ru
#+SELECT_TAGS: export
#+EXCLUDE_TAGS: noexport
#+CREATOR: Emacs 27.0.50 (Org mode 9.1.6)

* Задача
  Внести изменения в существующий программный код. 
* Порядок работы
** Определение точек изменения
   1. Для начала необходимо четко сформулировать поведение, которое
      нужно получить в результате модификаций. Это может быть:
      * исправление ошибки,
      * внедрение нового поведения
      * сохранение текущего поведения (например, при реорганизации кода).
   2. Прочитать код, и обнаружить в нем участок, отвественный за
      поведение, которое должно быть модифицированно.
      * При наличии тестов, описывающих имеющееся поведение,
        проверяется актуальность теста (соответствие описанного
        поведения ожидаемому), а так же его работоспособность и
        предсказуемость. Помимо успешного запуска на кейсе с
        положительным исходом, нужно внести логическую ошибку в
        процедуру теста, а после во входные данные, чтобы получить ожидаемый
        провал. 
        В этом случае тестируемая функция есть место внесения
        изменений. 
      * Если тесты отсутствуют вообще или имеются только
        интеграционные тесты, то тело программы непосредственно
        читается, начиная от определений единиц программы (функций,
        классов, объектов и т.д.), в поиске тех, определение которых
        указывает на интересущее поведение. Контроль осуществляется
        чтением процедуры и\или структуры данных, расстановкой точек
        журналирования и запуском отладчика на интересующем участке.
   3. *Если код недостаточно понятен.* 
      1) В процессе чтения составлять примечания и рисовать схемы.

         - Цитата с.211:
           /Если чтение кода вызывает трудности, то имеет смысл начать/
           /составлять эскизы и делать пометки./ *Запишите сначала имя/*
           *последнего важного объекта, который вам встретился в коде, а*
           *затем имя следующего объекта. Если вы обнаружите между ними*
           *взаимосвязь, то соедините их линией.* /Такие эскизы не/
           /обязательно должны быть выполнены в стиле полноценных/
           /блок-схем, составленных на языке UML, или графов вызовов/
           /функций, построенных с использованием специальных условных/
           /обозначений/

      2) Распечатать длинные и трудночитаемые
         процедуры\методы\функции, и разметить листинги.
         - с.213
           * /Если требуется разделить виды ответственности, отметьте/
             /маркером группу соответствующих объектов. Если несколько/
             /объектов связывает нечто общее, то пометьте их/
             /специальным знаком, проставляемым рядом с ними, чтобы их/
             /легче было распознать. Старайтесь выполнять разметку/
             /разным цветом./
           * /Если требуется разобраться в крупном методе, то/
             /выровняйте блоки его кода. Зачастую отступы в длинных/
             /методах сильно затрудняют чтение их кода. Для того чтобы/
             /выровнять блоки кода, проведите линии от начала до конца/
             /каждого блока или же снабдите конец блока комментариями в/
             /виде исходного текста цикла или же условия, с которого/
             /этот блок начинается. Блоки проще всего выравнивать/
             /изнутри наружу. Например, работая с кодом, написанным на/
             /одном из языков семейства C, начните его чтение с верхней/
             /части листинга, пропуская каждую открывающую фигурную/
             /скобку и продолжая до тех пор, пока вы не достигните/
             /первой закрывающей фигурной скобки. Пометьте эту/
             /закрывающую скобку, а затем вернитесь назад и пометьте/
             /соответствующую ей открывающую скобку. Продолжайте чтение/
             /кода до тех пор, пока не достигните следующей закрывающей/
             /фигурной скобки, и повторите описанные выше действия,/
             /вернувшись назад к соответствующей открывающей скобке./
           * /Если требуется разделить на части крупный метод, обведите/
             /кружком код, который нужно извлечь. Пометьте код его связующим числом./
           * /Если требуется понять влияние определенного изменения,/
             /которое вы собираетесь внести в код, то вместо/
             /составления эскиза воздействий пометьте строки кода,/
             /которые вам предстоит изменить. Затем пометьте каждую/
             /переменную, значение которой может измениться в/
             /результате такого изменения, а также каждый вызов метода,/
             /на который оно может оказать влияние. Далее пометьте/
             /переменные и методы, на которые могут воздействовать/
             /помеченные объекты. Повторите эти действия столько раз,/
             /сколько требуется, чтобы выяснить, каким образом/
             /воздействия распространяются от места внесения/
             /изменения. Делая это, вы сможете лучше понять, что именно/
             /вам следует тестировать./
      3) Провести черновой рефакторинг кода, в котором пытаетесь
         разобраться.
         Перед началом убедиться, что в файлах нет
         непроиндексированных изменений. В противном случае, либо
         сбросить их (если не нужны), либо отметить в СКВ. 
         Попытаться реорганизовать код, не прибегая к написанию
         тестов. 
         Этот метод нужен *только для прояснения структуры кода и*
         *результат такого рефакторинга не должен попасть в индекс*
         *СКВ.*
         - с.214
           /Черновая реорганизация кода — отличный способ добраться до/
           /сути и узнать по-настоящему, как код работает, хотя это и/
           /рискованное занятие по двум причинам. Во-первых, мы/
           /совершаем большую ошибку, когда в результате реорганизации/
           /кода приходим к выводу, что система делает не то, что/
           /должна делать. В этом случае у нас возникает неверное/
           /представление о системе, что может привести к осложнениям,/
           /когда мы приступим к настоящей реорганизации кода. И/
           /во-вторых, мы можем настолько пристраститься к такой/
           /реорганизации кода, что начнем постоянно рассматривать его/
           /именно с этих позиций. Разумеется, это не обязательно/
           /плохо, но добром может и не кончиться. По целому ряду/
           /причин структура кода может и не оказаться такой же самой,/
           /когда мы, наконец, дойдем до настоящей реорганизации/
           /кода. В частности, можно найти более совершенный способ/
           /структуризации кода. Кроме того, наш код может со временем/
           /измениться, а вместе с ним и наше представление о нем. Если/
           /же мы слишком привязаны к конечной цели черновой/
           /реорганизации кода, то можем просто упустить из виду все/
           /эти представления о коде./

      4) Если в процессе разбора участок кода, предположительно,
         бесполезен и не используется, то его можно удалить. В случае,
         если это приведет к ошибкам и нарушениям работы, его можно
         будет восстановить из предыдущих версий.
         - с.214
           /Ненужный код ничего полезного не делает, а только/
           /мешает. Иногда удаление ненужного кода считается напрасной/
           /тратой времени. Ведь кто-то потратил время, чтобы написать/
           /этот код, а значит, он может для чего-нибудь/
           /пригодиться. Для этой цели и служит система контроля/
           /версий. Такой код будет находиться в предыдущих версиях, и/
           /если он понадобится, то его можно всегда найти./

   4. *Если команде неясна структура приложения*.

      1) Упрощенно описать функцию системы и известные роли частей
         системы, и уточнить роли у коллег, разбирающих описываемые
         части системы. 
         В процессе стоит избегать излишнего ухода в детали реализации
         и сосредоточиться именно на ролях и функциях.
         Подобные обсуждения должны производиться постоянно, т.к. в
         процессе работы структура приложения неизбежно изменяется,
         так же могут обнаружиться ошибки в понимании.
         - с.219
           /Группы разработчиков могут дойти только до этой черты,/
           /когда система, над которой они работают, представляет для/
           /них сплошную тайну. Как ни странно, простое описание работы/
           /системы служит своеобразным ориентиром при поиске/
           /подходящих мест для ввода новых свойств. Кроме того, оно/
           /делает саму систему намного менее устрашающей. Почаще/
           /описывайте систему своим коллегам по работе, чтобы/
           /составить общее представление о ней. Описывайте ее/
           /по-разному, подбирая подходящие понятия по степени их/
           /важности. Когда вы станете обдумывать изменения в системе,/
           /заметите, что одни изменения в большей степени/
           /соответствуют описанию системы, чем другие, т.е. они делают/
           /более краткое описание системы больше похожим на/
           /правду. Если вам приходится выбирать между двумя способами/
           /сделать что-то с системой, то ее описание поможет вам лучше/
           /понять, каким из этих способов система станет более понятной./

      2) Описать известные или предполагаемые *событийные*
         *взаимодействия* в виде схем, модифицируя ее в процессе
         обсуждения. 
         Цель этого этапа не составление архитектурной документации, а
         добиться понимания работы системы, поэтому допустимо
         пренебрегать правилами стандартами оформления.
         - c. 220-221
           /Вот как это делается. Тот, кто описывает систему,/
           /пользуется стопкой пустых учетных карточек, выкладывая их/
           /одну за другой на стол. Он может перемещать карточки,/
           /указывать на них и делать с ними все, что требуется для/
           /описания типичных объектов и их взаимодействия в/
           /системе. Рассмотрим для примера описание системы/
           /голосования в оперативном режиме. Ниже приведены пояснения/
           /того, кто описывает данную систему, и его действия,/
           /указываемые в скобках./
           “/Вот как работает система голосования в реальном масштабе/
           /времени. Это сеанс связи с клиентом” (указывает на/
           /карточку)./
           “/В /каждом сеансе связи устанавливаются два соединения —/
           /входящее и исходящее” (накладывает каждую карточку на/
           /первоначальную и указывает на них по очереди)./
           “/При запуске системы организуется сеанс связи на сервере/
           /вот здесь” (выкладывает карточку справа)./
           “/На каждый сеанс связи с сервером также приходятся два/
           /соединения” (выкладывает две карточки, обозначающие/
           /соединения справа)./
           ...
           /Вместо карточек вы можете воспользоваться любыми другими/
           /подходящими для этой цели предметами. Самое главное, что,/
           /располагая и перемещая их, вы можете наглядно показать,/
           /каким образом взаимодействуют отдельные части/
           /системы. Такой прием нередко упрощает понимание сложных/
           /вещей, помогает разобраться в запутанных ситуациях, а также/
           /способствует лучшему запоминанию отдельных/
           /структур. Применяя способ открытого событийного/
           /взаимодействия классов, следует руководствоваться лишь/
           /двумя принципами./
           + /Карточки обозначают экземпляры, а не классы./
           + /Накладывающиеся карточки обозначают совокупность экземпляров./

** Нахождение тестовых точек
** Разрыв зависимостей
** Написание тестов
** Внесение изменений и реорганизация кода.
